# Snapshot report for `test/SettingsFolder.ts`

The actual snapshot is saved in `SettingsFolder.ts.snap`.

Generated by [AVA](https://ava.li).

## snapshot testing

> Snapshot 1

    `clone() {␍␊
            const clone = new Settings(this.gateway, this.target, this.id);␍␊
            clone._patch(this.toJSON());␍␊
            return clone;␍␊
        }`

> Snapshot 2

    `async sync(force = this.existenceStatus === 0 /* Unsynchronized */) {␍␊
            // If not force and the instance has already been synchronized with the database, return this␍␊
            if (!force && this.existenceStatus !== null)␍␊
                return this;␍␊
            // Push a synchronization task to the request handler queue␍␊
            const data = await this.gateway.requestHandler.push(this.id);␍␊
            if (data) {␍␊
                this.existenceStatus = 1 /* Exists */;␍␊
                this._patch(data);␍␊
                this.gateway.client.emit('settingsSync', this);␍␊
            }␍␊
            else {␍␊
                this.existenceStatus = 2 /* NotExists */;␍␊
            }␍␊
            return this;␍␊
        }`

> Snapshot 3

    `async destroy() {␍␊
            await this.sync();␍␊
            if (this.existenceStatus === 1 /* Exists */) {␍␊
                const { provider } = this.gateway;␍␊
                if (provider === null)␍␊
                    throw new Error('The provider was not available during the destroy operation.');␍␊
                await provider.delete(this.gateway.name, this.id);␍␊
                this.gateway.client.emit('settingsDelete', this);␍␊
                this._init(this, this.schema);␍␊
                this.existenceStatus = 2 /* NotExists */;␍␊
            }␍␊
            return this;␍␊
        }`

> Snapshot 4

    '[object Object]'

> Snapshot 5

    `get(path) {␍␊
            try {␍␊
                return path.split('.').reduce((folder, key) => Map.prototype.get.call(folder, key), this);␍␊
            }␍␊
            catch {␍␊
                return undefined;␍␊
            }␍␊
        }`

> Snapshot 6

    `pluck(...paths) {␍␊
            return paths.map(path => {␍␊
                const value = this.get(path);␍␊
                return value instanceof SettingsFolder ? value.toJSON() : value;␍␊
            });␍␊
        }`

> Snapshot 7

    `resolve(...paths) {␍␊
            if (this.base === null)␍␊
                throw new Error('Cannot retrieve guild from a non-ready settings instance.');␍␊
            const guild = this.client.guilds.resolve(this.base.target);␍␊
            const language = guild === null ? this.base.gateway.client.languages.default : guild.language;␍␊
            return Promise.all(paths.map(path => {␍␊
                const entry = this.schema.get(path);␍␊
                if (typeof entry === 'undefined')␍␊
                    return undefined;␍␊
                return entry.type === 'Folder' ?␍␊
                    this._resolveFolder({␍␊
                        folder: entry,␍␊
                        language,␍␊
                        guild,␍␊
                        extra: null␍␊
                    }) :␍␊
                    this._resolveEntry({␍␊
                        entry: entry,␍␊
                        language,␍␊
                        guild,␍␊
                        extra: null␍␊
                    });␍␊
            }));␍␊
        }`

> Snapshot 8

    `async reset(paths = [...this.keys()], options = {}) {␍␊
            if (this.base === null) {␍␊
                throw new Error('Cannot reset keys from a non-ready settings instance.');␍␊
            }␍␊
            if (this.base.existenceStatus === 0 /* Unsynchronized */) {␍␊
                throw new Error('Cannot reset keys from a pending to synchronize settings instance. Perhaps you want to call `sync()` first.');␍␊
            }␍␊
            if (typeof paths === 'string')␍␊
                paths = [paths];␍␊
            else if (utils_1.isObject(paths))␍␊
                paths = utils_1.objectToTuples(paths).map(entries => entries[0]);␍␊
            const { client, schema } = this;␍␊
            const onlyConfigurable = typeof options.onlyConfigurable === 'undefined' ? false : options.onlyConfigurable;␍␊
            const guild = client.guilds.resolve(typeof options.guild === 'undefined' ? this.base.target : options.guild);␍␊
            const language = guild === null ? client.languages.default : guild.language;␍␊
            const extra = options.extraContext;␍␊
            const changes = [];␍␊
            for (const path of paths) {␍␊
                const entry = schema.get(path);␍␊
                // If the key does not exist, throw␍␊
                if (typeof entry === 'undefined')␍␊
                    throw language.get('SETTING_GATEWAY_KEY_NOEXT', path);␍␊
                if (entry.type === 'Folder')␍␊
                    this._resetSchemaFolder(changes, entry, path, language, onlyConfigurable);␍␊
                else␍␊
                    this._resetSchemaEntry(changes, entry, path, language, onlyConfigurable);␍␊
            }␍␊
            await this._save({ changes, guild, language, extra });␍␊
            return changes;␍␊
        }`

> Snapshot 9

    `async update(pathOrEntries, valueOrOptions, options = {}) {␍␊
            if (this.base === null) {␍␊
                throw new Error('Cannot update keys from a non-ready settings instance.');␍␊
            }␍␊
            if (this.base.existenceStatus === 0 /* Unsynchronized */) {␍␊
                throw new Error('Cannot update keys from a pending to synchronize settings instance. Perhaps you want to call `sync()` first.');␍␊
            }␍␊
            let entries;␍␊
            if (typeof pathOrEntries === 'string') {␍␊
                entries = [[pathOrEntries, valueOrOptions]];␍␊
            }␍␊
            else if (utils_1.isObject(pathOrEntries)) {␍␊
                entries = utils_1.objectToTuples(pathOrEntries);␍␊
                options = valueOrOptions;␍␊
            }␍␊
            else {␍␊
                entries = pathOrEntries;␍␊
                options = valueOrOptions;␍␊
            }␍␊
            const { client, schema } = this;␍␊
            const onlyConfigurable = typeof options.onlyConfigurable === 'undefined' ? false : options.onlyConfigurable;␍␊
            const arrayAction = typeof options.arrayAction === 'undefined' ? "auto" /* Auto */ : options.arrayAction;␍␊
            const arrayIndex = typeof options.arrayIndex === 'undefined' ? null : options.arrayIndex;␍␊
            const guild = client.guilds.resolve(typeof options.guild === 'undefined' ? this.base.target : options.guild);␍␊
            const language = guild === null ? client.languages.default : guild.language;␍␊
            const extra = options.extraContext;␍␊
            const internalOptions = { arrayAction, arrayIndex, onlyConfigurable };␍␊
            const promises = [];␍␊
            for (const [path, value] of entries) {␍␊
                const entry = schema.get(path);␍␊
                // If the key does not exist, throw␍␊
                if (typeof entry === 'undefined')␍␊
                    throw language.get('SETTING_GATEWAY_KEY_NOEXT', path);␍␊
                if (entry.type === 'Folder') {␍␊
                    const keys = onlyConfigurable ?␍␊
                        [...entry.values()].filter(val => val.type !== 'Folder').map(val => val.key) :␍␊
                        [...entry.keys()];␍␊
                    throw keys.length > 0 ?␍␊
                        language.get('SETTING_GATEWAY_CHOOSE_KEY', keys.join('\\', \\'')) :␍␊
                        language.get('SETTING_GATEWAY_UNCONFIGURABLE_FOLDER');␍␊
                }␍␊
                promises.push(this._updateSchemaEntry(path, value, { entry: entry, language, guild, extra }, internalOptions));␍␊
            }␍␊
            const changes = await Promise.all(promises);␍␊
            await this._save({ changes, guild, language, extra });␍␊
            return changes;␍␊
        }`

> Snapshot 10

    `toJSON() {␍␊
            const json = {};␍␊
            for (const [key, value] of super.entries()) {␍␊
                json[key] = value instanceof SettingsFolder ? value.toJSON() : value;␍␊
            }␍␊
            return json;␍␊
        }`
